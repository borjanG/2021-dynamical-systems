# out = self.fc1(x)
        # out = self.non_linearity(out)

        #out = self.fc2(out)
        #out = self.non_linearity(out)
        #out = self.fc3(out)

        # #### ----------------
        # #### Added by Borjan:
        # #### We begin with the time-dependent parameters
        # #### Here T=2.

        # #### ------------------------
        # A = self.fc2_time.weight
        # b = self.fc2_time.bias
        # phi1 = lambda t, k: sin(k*t)
        # phi2 = lambda t, k: cos(k*t)

        # At = A[:self.hidden_dim]*phi1(1, pi/2)
        # bt = b[:self.hidden_dim]*phi1(1, pi/2)
        
        # for k in range(1, self.filtering):
        #     if k <= self.fourier:
        #         At += A[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t, k)
        #         bt += b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t, k)
        #     else:
        #         At += A[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t, k-self.fourier)
        #         bt += b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t, k-self.fourier)
        # out = out.matmul(At.t())+bt
        # out = self.non_linearity(out)
        # out = self.fc3(out)
        # #### ------------------------

        # #### ------------------------
        # #### Ce cas c'est z'(t) = w_2(t)\sigma(w_1(t)z(t)+b_1(t))+b_2(t)

        # w1 = self.fc1_time.weight
        # b1 = self.fc1_time.bias

        # w2 = self.fc3_time.weight
        # b2 = self.fc3_time.bias

        # phi1 = lambda t, k: sin(k*t)
        # phi2 = lambda t, k: cos(k*t)

        # wt_1 = w1[:self.hidden_dim]*phi1(1, pi/2)
        # bt_1 = b1[:self.hidden_dim]*phi1(1, pi/2)

        # wt_2 = w2[:self.input_dim]*phi1(1, pi/2)
        # bt_2 = b2[:self.input_dim]*phi1(1, pi/2)

        # for k in range(1, self.filtering):
        #     if k<= self.fourier:
        #         wt_1 += w1[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t,k)
        #         bt_1 += b1[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t,k)

        #         wt_2 += w2[k*self.input_dim:self.input_dim*(k+1)]*phi2(t,k)
        #         bt_2 += b2[k*self.input_dim:self.input_dim*(k+1)]*phi2(t,k)
        #     else:
        #         wt_1 += w1[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t,k-self.fourier)
        #         bt_1 += b1[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t,k-self.fourier)

        #         wt_2 += w2[k*self.input_dim:self.input_dim*(k+1)]*phi1(t,k-self.fourier)
        #         bt_2 += b2[k*self.input_dim:self.input_dim*(k+1)]*phi1(t,k-self.fourier)
        # out = x.matmul(wt_1.t())+bt_1
        # out = self.non_linearity(out)
        # out = out.matmul(wt_2.t())+bt_2

        # ### Old Scheme by Dupont
        # t_vec = torch.ones(x.shape[0], 1).to(self.device) * t
        # # Shape (batch_size, data_dim + 1)
        # t_and_x = torch.cat([t_vec, x], 1)
        # # Shape (batch_size, hidden_dim)
        # out = self.fc1(t_and_x)
        # out = self.non_linearity(out)
        # out = self.fc2(out)
        # out = self.non_linearity(out)
        # out = self.fc3(out)

        # #### ------------------------
        # #### Ce cas c'est z'(t) = \sigma(Az(t)+b)
        # out = self.fc2(x)
        # out = self.non_linearity(out)
        # #### ------------------------

        # #### ------------------------
        # #### Cas z'(t) = \sigma(A(t)z(t)+b(t))
        # A = self.fc2_time.weight
        # b = self.fc2_time.bias
        # phi = lambda t, k: sqrt(2/10)*sin(pi*k*t/10)
        # At = A[:self.hidden_dim]*phi(t,0)
        # bt = b[:self.hidden_dim]*phi(t,0)
        # for k in range(1, self.filtering):
        #     At+= A[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi(t, k)
        #     bt+= b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi(t, k)
        # out = x.matmul(At.t())+bt
        # out = self.non_linearity(out)
        # #### ------------------------

        # #### ------------------------
        # #### Cas z'(t) = A\sigma(z(t))+b
        # if t == 0: 
        #     out = self.fc1(x)
        #     out = self.non_linearity(out)
        # else:
        #     out = self.non_linearity(x)
        # out = self.fc2(out)
        # #### ------------------------

        # #### ------------------------
        # #### Cas z'(t) = A(t)\sigma(z(t))+b(t)
        # if t == 0:
        #     out = self.fc1(x)
        #     out = self.non_linearity(out)
        # else:
        #     out = self.non_linearity(x)
        # phi1 = lambda t, k: sin(k*t)
        # phi2 = lambda t, k: cos(k*t)

        # w = self.fc2_time.weight
        # b = self.fc2_time.bias        

        # wt = w[:self.hidden_dim]*phi1(1, pi/2)
        # bt = b[:self.hidden_dim]*phi1(1, pi/2)

        # for k in range(1, self.filtering):
        #     if k<= self.fourier:
        #         wt += w[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t,k)
        #         bt += b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t,k)
        #     else:
        #         wt += w[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t,k-self.fourier)
        #         bt += b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t,k-self.fourier)
        # out = out.matmul(wt.t())+bt
        # #### ------------------------

        # #### end Borjan
        # ####------------

        ########
        ########
        # weights = self.fc1_time.weight
        # biases = self.fc1_time.bias

        # At = lambda k, t: (1-(t-dt*k)/(dt))*weights[k*self.hidden_dim:(k+1)*self.hidden_dim] + (t-dt*k)/dt*weights[(k+1)*self.hidden_dim:(k+2)*self.hidden_dim]
        # bt = lambda k, t: (1-(t-dt*k)/(dt))*biases[k*self.hidden_dim:(k+1)*self.hidden_dim] + (t-dt*k)/dt*biases[(k+1)*self.hidden_dim:(k+2)*self.hidden_dim]

        # if k <= self.filtering-2:
        #     out = x.matmul(At(k,t).t())+bt(k,t)
        # else:
        #     out = x.matmul(At(self.filtering-2, t*(self.filtering-1)).t())+bt(self.filtering-2, t*(self.filtering-1))
        # out = self.non_linearity(out)
        # out = self.fc3(out)

        # ##.. Time-related parameters. I should define T as a global variable..
        # ##.. We recall that we use a multi-grid approach for state-control discretisation
        # ##.. Thus we have self.filtering number of control nodes

        ##.. We use a trapezoidal colocation for approximating the control using the nodes
        # At = lambda k, t: (1-(t-dt*k)/(dt))*weights[k*self.input_dim:(k+1)*self.input_dim] + (t-dt*k)/dt*weights[(k+1)*self.input_dim:(k+2)*self.input_dim]
        # bt = lambda k, t: (1-(t-dt*k)/(dt))*biases[k*self.input_dim:(k+1)*self.input_dim] + (t-dt*k)/dt*biases[(k+1)*self.input_dim:(k+2)*self.input_dim]

        # ##.. We recall that we now use the model x'(t) = w(t)s(x(t))+b(t)
        # if k <= self.filtering-2:
        #     out = out.matmul(At(k,t).t())+bt(k,t)
        # else:
        #     out = out.matmul(At(self.filtering-2, t*(self.filtering-1)).t())+bt(self.filtering-2, t*(self.filtering-1))
        

        # phi1 = lambda t, k: sin(k*t)
        # phi2 = lambda t, k: cos(k*t)

        # w = self.fc2_time.weight
        # b = self.fc2_time.bias        

        # wt = w[:self.hidden_dim]*phi1(1, pi/2)
        # bt = b[:self.hidden_dim]*phi1(1, pi/2)

        # for k in range(1, self.filtering):
        #     if k<= self.fourier:
        #         wt += w[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t,k)
        #         bt += b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi2(t,k)
        #     else:
        #         wt += w[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t,k-self.fourier)
        #         bt += b[k*self.hidden_dim:self.hidden_dim*(k+1)]*phi1(t,k-self.fourier)
        # out = out.matmul(wt.t())+bt